import { Question } from '../../types/question';

export const componentsQuestions: Omit<Question, 'id'>[] = [
  {
    question: 'Что такое React компонент?',
    options: [
      'Функция или класс, возвращающий JSX',
      'Переменная',
      'Метод',
      'Библиотека',
    ],
    correctAnswer: 0,
    explanation: 'Компонент - это основная единица React приложения, которая возвращает JSX. Подробнее: https://react.dev/learn',
    category: 'Компоненты',
    difficulty: 'Легкий',
    tags: ['компоненты'],
    type: 'single',
  },
  {
    question: 'Какие характеристики props верны в React?',
    options: [
      'Props можно изменять внутри компонента',
      'Props передаются от родительского компонента к дочернему',
      'Props доступны только в классовых компонентах',
      'Props это внутреннее состояние компонента',
    ],
    correctAnswer: [1],
    explanation: 'Props передаются от родителя к ребенку и являются неизменяемыми. Подробнее: https://react.dev/learn/passing-props-to-a-component',
    category: 'Компоненты',
    difficulty: 'Средний',
    tags: ['props', 'компоненты'],
    type: 'multiple',
  },
  {
    question: 'В чем разница между функциональными и классовыми компонентами?',
    options: [
      'Нет разницы',
      'Функциональные проще и используют Hooks',
      'Классовые быстрее',
      'Только классовые поддерживают состояние',
    ],
    correctAnswer: 1,
    explanation: 'Функциональные компоненты проще, используют Hooks для состояния и рекомендуются в React. Подробнее: https://react.dev/reference/react',
    category: 'Компоненты',
    difficulty: 'Средний',
    tags: ['компоненты', 'hooks'],
    type: 'single',
  },
  {
    question: 'Что такое defaultProps?',
    options: [
      'Значения по умолчанию для props',
      'Внутреннее состояние',
      'Метод жизненного цикла',
      'Событие',
    ],
    correctAnswer: 0,
    explanation: 'defaultProps задает значения по умолчанию для props компонента. Подробнее: https://react.dev/learn/passing-props-to-a-component',
    category: 'Компоненты',
    difficulty: 'Средний',
    tags: ['компоненты', 'props'],
    type: 'single',
  },
  {
    question: 'Что делает PropTypes?',
    options: [
      'Типизация props во время разработки',
      'Работа с API',
      'Управление состоянием',
      'Рендеринг компонентов',
    ],
    correctAnswer: 0,
    explanation: 'PropTypes предоставляет проверку типов props во время разработки. Подробнее: https://react.dev/learn/passing-props-to-a-component',
    category: 'Компоненты',
    difficulty: 'Средний',
    tags: ['компоненты', 'props'],
    type: 'single',
  },
  {
    question: 'Можно ли использовать оба типа компонентов в одном приложении?',
    options: [
      'Нет, только один тип',
      'Да, можно смешивать функциональные и классовые',
      'Только с дополнительными библиотеками',
      'Только в старых версиях React',
    ],
    correctAnswer: 1,
    explanation: 'Да, можно использовать оба типа компонентов в одном приложении, хотя функциональные компоненты предпочтительнее. Подробнее: https://react.dev/learn',
    category: 'Компоненты',
    difficulty: 'Легкий',
    tags: ['компоненты', 'functional-components', 'class-components'],
    type: 'single',
  },
  {
    question: 'Что такое чистая функция в контексте React компонентов?',
    options: [
      'Компонент который возвращает только JSX',
      'Компонент который не имеет side effects и зависит только от props',
      'Компонент без props',
      'Устаревший компонент',
    ],
    correctAnswer: 1,
    explanation: 'Чистая функция (компонент) возвращает одинаковый результат для одинаковых входных данных и не имеет побочных эффектов. Подробнее: https://react.dev/learn/keeping-components-pure',
    category: 'Компоненты',
    difficulty: 'Средний',
    tags: ['компоненты', 'pure-functions'],
    type: 'single',
  },
  {
    question: 'Что такое children в React компонентах?',
    options: [
      'Внутреннее состояние компонента',
      'Специальный prop содержащий дочерние элементы',
      'React Hook',
      'Метод компонента',
    ],
    correctAnswer: 1,
    explanation: 'children - это специальный prop, который содержит дочерние элементы, переданные в компонент. Подробнее: https://react.dev/learn/passing-props-to-a-component',
    category: 'Компоненты',
    difficulty: 'Легкий',
    tags: ['компоненты', 'children', 'props'],
    type: 'single',
  },
  {
    question: 'Как передать children в компонент?',
    options: [
      'Только через props',
      'Между открывающим и закрывающим тегами компонента',
      'Только программно',
      'Только в классовом компоненте',
    ],
    correctAnswer: 1,
    explanation: 'Children передаются между открывающим и закрывающим тегами компонента: <Component>children</Component>. Подробнее: https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children',
    category: 'Компоненты',
    difficulty: 'Легкий',
    tags: ['компоненты', 'children'],
    type: 'single',
  },
  {
    question: 'Что такое render props паттерн?',
    options: [
      'Props для рендеринга',
      'Паттерн где компонент получает функцию через prop и использует её для рендеринга',
      'Тип компонента',
      'DOM API',
    ],
    correctAnswer: 1,
    explanation: 'Render props - это паттерн где компонент получает функцию через prop и использует её для динамического рендеринга части UI. Подробнее: https://react.dev/learn',
    category: 'Компоненты',
    difficulty: 'Сложный',
    tags: ['компоненты', 'render-props', 'patterns'],
    type: 'single',
  },
  {
    question: 'Как работают computed props в React?',
    options: [
      'React вычисляет props автоматически',
      'Можно вычислять производные значения от props внутри компонента',
      'Props всегда статичны',
      'Computed props не поддерживаются',
    ],
    correctAnswer: 1,
    explanation: 'Computed props можно создать вычисляя значения на основе входящих props внутри компонента. Подробнее: https://react.dev/learn/passing-props-to-a-component',
    category: 'Компоненты',
    difficulty: 'Средний',
    tags: ['компоненты', 'props'],
    type: 'single',
  },
  {
    question: 'Как избежать prop drilling?',
    options: [
      'Создавать все компоненты на одном уровне',
      'Использовать Context API или глобальное управление состоянием',
      'Не передавать props',
      'Использовать только локальные компоненты',
    ],
    correctAnswer: 1,
    explanation: 'Prop drilling можно избежать используя Context API или библиотеки управления глобальным состоянием. Подробнее: https://react.dev/learn/passing-props-to-a-component',
    category: 'Компоненты',
    difficulty: 'Средний',
    tags: ['компоненты', 'props', 'context'],
    type: 'single',
  },
  {
    question: 'Что такое compound компонент?',
    options: [
      'Сложный компонент',
      'Группа компонентов работающих вместе через неявное разделение состояния',
      'Компонент с множеством функций',
      'Устаревший компонент',
    ],
    correctAnswer: 1,
    explanation: 'Compound компонент - это паттерн где группа компонентов работает вместе через неявное разделение состояния. Подробнее: https://react.dev/learn',
    category: 'Компоненты',
    difficulty: 'Сложный',
    tags: ['компоненты', 'compound'],
    type: 'single',
  },
  {
    question: 'Что такое presentation компонент?',
    options: [
      'Компонент для презентаций',
      'Компонент который получает данные и обратные вызовы через props',
      'Классовый компонент',
      'Компонент с анимацией',
    ],
    correctAnswer: 1,
    explanation: 'Presentation компонент (dumb/stateless) получает данные и обратные вызовы через props, не содержит бизнес-логику. Подробнее: https://react.dev/learn',
    category: 'Компоненты',
    difficulty: 'Средний',
    tags: ['компоненты', 'presentation', 'container'],
    type: 'single',
  },
  {
    question: 'Что такое container компонент?',
    options: [
      'Компонент обертка',
      'Компонент который управляет данными и логикой',
      'DOM контейнер',
      'Специальный React компонент',
    ],
    correctAnswer: 1,
    explanation: 'Container компонент (smart/stateful) управляет данными и содержит бизнес-логику, передает данные presentation компонентам. Подробнее: https://react.dev/learn',
    category: 'Компоненты',
    difficulty: 'Средний',
    tags: ['компоненты', 'container', 'presentation'],
    type: 'single',
  },
  {
    question: 'Что такое props spreading?',
    options: [
      'Удаление props',
      'Использование синтаксиса {...props} для передачи всех свойств',
      'Копирование props',
      'Объединение props',
    ],
    correctAnswer: 1,
    explanation: 'Props spreading позволяет передать все свойства объекта как отдельные props используя синтаксис {...props}.',
    category: 'Компоненты',
    difficulty: 'Легкий',
    tags: ['компоненты', 'props', 'spread'],
    type: 'single',
  },
  {
    question: 'Когда использовать React.memo для компонента?',
    options: [
      'Всегда для всех компонентов',
      'Когда компонент часто рендерится с теми же props',
      'Никогда не использовать',
      'Только для классовых компонентов',
    ],
    correctAnswer: 1,
    explanation: 'React.memo следует использовать когда компонент часто рендерится с неизменяющимися props для оптимизации производительности. Подробнее: https://react.dev/reference/react/memo',
    category: 'Компоненты',
    difficulty: 'Средний',
    tags: ['компоненты', 'memo', 'performance'],
    type: 'single',
  },
  {
    question: 'Что такое forwardRef?',
    options: [
      'Механизм передачи ref дочернему компоненту',
      'Удаление ref',
      'Создание ref',
      'Копирование ref',
    ],
    correctAnswer: 0,
    explanation: 'forwardRef позволяет компоненту получить ref от родителя и передать его дальше дочернему DOM элементу или компоненту. Подробнее: https://react.dev/reference/react/forwardRef',
    category: 'Компоненты',
    difficulty: 'Сложный',
    tags: ['компоненты', 'refs', 'forwardref'],
    type: 'single',
  },
  {
    question: 'Что такое useImperativeHandle?',
    options: [
      'Хук для работы с refs',
      'Кастомный хук',
      'Метод компонента',
      'DOM API',
    ],
    correctAnswer: 0,
    explanation: 'useImperativeHandle позволяет определить значение экземпляра, которое может быть доступно родительским компонентам при использовании ref. Подробнее: https://react.dev/reference/react/useImperativeHandle',
    category: 'Компоненты',
    difficulty: 'Сложный',
    tags: ['компоненты', 'useImperativeHandle', 'refs'],
    type: 'single',
  },
  {
    question: 'Что такое context в компоненте?',
    options: [
      'Внутреннее состояние',
      'Механизм передачи данных без props drilling',
      'DOM контекст',
      'JavaScript контекст',
    ],
    correctAnswer: 1,
    explanation: 'Context позволяет передавать данные через дерево компонентов без явной передачи props на каждом уровне. Подробнее: https://react.dev/reference/react/useContext',
    category: 'Компоненты',
    difficulty: 'Средний',
    tags: ['компоненты', 'context'],
    type: 'single',
  },
  {
    question: 'Что такое lifecycle методы в классовых компонентах?',
    options: [
      'Методы автоматически вызываемые в разные моменты жизненного цикла',
      'Обычные методы компонента',
      'React Hooks',
      'DOM методы',
    ],
    correctAnswer: 0,
    explanation: 'Lifecycle методы (componentDidMount, componentDidUpdate, etc.) вызываются React в разные моменты жизненного цикла компонента. Подробнее: https://react.dev/learn',
    category: 'Компоненты',
    difficulty: 'Средний',
    tags: ['компоненты', 'lifecycle', 'class-components'],
    type: 'single',
  },
  {
    question: 'Какие lifecycle методы существуют в React?',
    options: [
      'componentDidMount, componentDidUpdate, componentWillUnmount и другие',
      'Только render',
      'Нет lifecycle методов',
      'Только constructor',
    ],
    correctAnswer: 0,
    explanation: 'Основные lifecycle методы: componentDidMount, componentDidUpdate, componentWillUnmount, и несколько других. Подробнее: https://react.dev/learn',
    category: 'Компоненты',
    difficulty: 'Средний',
    tags: ['компоненты', 'lifecycle'],
    type: 'single',
  },
  {
    question: 'Что делает componentDidMount?',
    options: [
      'Вызывается после первого рендера компонента',
      'Вызывается перед размонтированием',
      'Вызывается при каждом update',
      'Вызывается до рендера',
    ],
    correctAnswer: 0,
    explanation: 'componentDidMount вызывается после того как компонент смонтирован (отрендерен) в DOM дерево. Подробнее: https://react.dev/learn',
    category: 'Компоненты',
    difficulty: 'Средний',
    tags: ['компоненты', 'componentDidMount', 'lifecycle'],
    type: 'single',
  },
  {
    question: 'Что делает componentDidUpdate?',
    options: [
      'Вызывается после каждого обновления компонента',
      'Вызывается перед размонтированием',
      'Вызывается до первого рендера',
      'Вызывается один раз',
    ],
    correctAnswer: 0,
    explanation: 'componentDidUpdate вызывается сразу после обновления компонента (но не после первого рендера). Подробнее: https://react.dev/learn',
    category: 'Компоненты',
    difficulty: 'Средний',
    tags: ['компоненты', 'componentDidUpdate', 'lifecycle'],
    type: 'single',
  },
  {
    question: 'Что делает componentWillUnmount?',
    options: [
      'Вызывается перед размонтированием компонента',
      'Вызывается после первого рендера',
      'Вызывается при каждом update',
      'Вызывается до рендера',
    ],
    correctAnswer: 0,
    explanation: 'componentWillUnmount вызывается непосредственно перед размонтированием и удалением компонента из DOM. Подробнее: https://react.dev/learn',
    category: 'Компоненты',
    difficulty: 'Средний',
    tags: ['компоненты', 'componentWillUnmount', 'lifecycle'],
    type: 'single',
  },
  {
    question: 'Что такое error boundaries?',
    options: [
      'Границы ошибок - компоненты перехватывающие ошибки в дереве',
      'Границы DOM',
      'CSS границы',
      'JavaScript границы',
    ],
    correctAnswer: 0,
    explanation: 'Error boundaries - это специальные компоненты, которые перехватывают JavaScript ошибки в любом месте дерева дочерних компонентов. Подробнее: https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary',
    category: 'Компоненты',
    difficulty: 'Сложный',
    tags: ['компоненты', 'error-boundaries'],
    type: 'single',
  },
  {
    question: 'Что может отловить error boundary?',
    options: [
      'Все ошибки в приложении',
      'Ошибки рендеринга, lifecycle методов и конструкторов компонентов',
      'Асинхронный код',
      'Event handlers',
    ],
    correctAnswer: 1,
    explanation: 'Error boundaries отлавливают ошибки рендеринга, lifecycle методов и конструкторов компонентов в их дереве. Подробнее: https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary',
    category: 'Компоненты',
    difficulty: 'Сложный',
    tags: ['компоненты', 'error-boundaries'],
    type: 'single',
  },
  {
    question: 'Что НЕ может отловить error boundary?',
    options: [
      'Ошибки в event handlers, асинхронном коде и серверном рендеринге',
      'Ошибки рендеринга',
      'Ошибки конструкторов',
      'Ошибки lifecycle методов',
    ],
    correctAnswer: 0,
    explanation: 'Error boundaries не отлавливают ошибки в event handlers, асинхронном коде и при серверном рендеринге. Подробнее: https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary',
    category: 'Компоненты',
    difficulty: 'Сложный',
    tags: ['компоненты', 'error-boundaries'],
    type: 'single',
  },
  {
    question: 'Что такое suspense boundary?',
    options: [
      'Граница ожидания для асинхронных компонентов',
      'Граница ошибок',
      'DOM граница',
      'CSS граница',
    ],
    correctAnswer: 0,
    explanation: 'Suspense boundary позволяет показывать fallback UI пока дочерние компоненты загружаются или рендерятся асинхронно. Подробнее: https://react.dev/reference/react/Suspense',
    category: 'Компоненты',
    difficulty: 'Сложный',
    tags: ['компоненты', 'suspense'],
    type: 'single',
  },
  {
    question: 'Что такое smart и dumb компоненты?',
    options: [
      'Альтернативные названия для container и presentation компонентов',
      'Типы DOM элементов',
      'React Hooks',
      'CSS компоненты',
    ],
    correctAnswer: 0,
    explanation: 'Smart (container) компоненты управляют состоянием и логикой, dumb (presentation) компоненты отображают UI. Подробнее: https://react.dev/learn',
    category: 'Компоненты',
    difficulty: 'Средний',
    tags: ['компоненты', 'smart', 'dumb'],
    type: 'single',
  },
  {
    question: 'Что такое uncontrolled input?',
    options: [
      'Input управляющий собственным значением через DOM',
      'Input с ошибкой',
      'Disabled input',
      'Readonly input',
    ],
    correctAnswer: 0,
    explanation: 'Uncontrolled input - это элемент формы, значение которого хранится в DOM, а не управляется React state. Подробнее: https://react.dev/learn/sharing-state-between-components',
    category: 'Компоненты',
    difficulty: 'Средний',
    tags: ['компоненты', 'forms', 'uncontrolled'],
    type: 'single',
  },
  {
    question: 'Что такое controlled input?',
    options: [
      'Input значение которого управляется React state',
      'Input с ошибкой',
      'Disabled input',
      'Readonly input',
    ],
    correctAnswer: 0,
    explanation: 'Controlled input - это элемент формы, значение которого контролируется React через state и onChange handler. Подробнее: https://react.dev/learn/sharing-state-between-components',
    category: 'Компоненты',
    difficulty: 'Средний',
    tags: ['компоненты', 'forms', 'controlled'],
    type: 'single',
  },
  {
    question: 'Что такое compound компонент паттерн?',
    options: [
      'Несколько компонентов работающих вместе',
      'Один большой компонент',
      'Компонент с множеством props',
      'Устаревший компонент',
    ],
    correctAnswer: 0,
    explanation: 'Compound компонент - это группа компонентов работающих вместе для создания сложной функциональности. Подробнее: https://react.dev/learn',
    category: 'Компоненты',
    difficulty: 'Сложный',
    tags: ['компоненты', 'compound', 'patterns'],
    type: 'single',
  },
  {
    question: 'Какие из следующих утверждений о React компонентах верны?',
    options: [
      'Компоненты можно вкладывать друг в друга',
      'Компоненты могут возвращать null',
      'Компоненты могут возвращать массивы элементов',
      'Все вышеперечисленное',
    ],
    correctAnswer: 3,
    explanation: 'React компоненты поддерживают вложенность, могут возвращать null и массивы элементов. Подробнее: https://react.dev/learn',
    category: 'Компоненты',
    difficulty: 'Средний',
    tags: ['компоненты'],
    type: 'single',
  },
  {
    question: 'Какое максимальное количество элементов может вернуть компонент?',
    options: [
      'Один элемент',
      'Несколько элементов через Fragment или массив',
      'Только JSX',
      'Неограниченное',
    ],
    correctAnswer: 1,
    explanation: 'Компонент может вернуть несколько элементов используя Fragment или массив, но обычно рекомендуется возвращать один элемент. Подробнее: https://react.dev/learn/writing-markup-with-jsx',
    category: 'Компоненты',
    difficulty: 'Средний',
    tags: ['компоненты', 'jsx'],
    type: 'single',
  },
  {
    question: 'Как правильно передать данные от родителя к ребенку?',
    options: [
      'Через props',
      'Через глобальные переменные',
      'Через state напрямую',
      'Через DOM',
    ],
    correctAnswer: 0,
    explanation: 'Данные передаются от родителя к ребенку через props. Подробнее: https://react.dev/learn/passing-props-to-a-component',
    category: 'Компоненты',
    difficulty: 'Легкий',
    tags: ['компоненты', 'props', 'data-flow'],
    type: 'single',
  },
  {
    question: 'Как передать обратный вызов от родителя к ребенку?',
    options: [
      'Через props как функцию',
      'Через state',
      'Через глобальные переменные',
      'Невозможно',
    ],
    correctAnswer: 0,
    explanation: 'Обратные вызовы передаются через props как функции. Подробнее: https://react.dev/learn/passing-props-to-a-component',
    category: 'Компоненты',
    difficulty: 'Средний',
    tags: ['компоненты', 'props', 'callbacks'],
    type: 'single',
  },
  {
    question: 'Что произойдет если попытаться изменить props внутри компонента?',
    options: [
      'Props изменятся',
      'React выдаст предупреждение',
      'Компонент перерендерится',
      'Ничего не произойдет',
    ],
    correctAnswer: 1,
    explanation: 'React выдаст предупреждение, так как props являются неизменяемыми (immutable). Подробнее: https://react.dev/learn/passing-props-to-a-component',
    category: 'Компоненты',
    difficulty: 'Средний',
    tags: ['компоненты', 'props'],
    type: 'single',
  },
  {
    question: 'Что такое key prop и зачем он нужен?',
    options: [
      'Уникальный идентификатор для оптимизации обновлений списков',
      'Секретный ключ',
      'CSS класс',
      'JavaScript переменная',
    ],
    correctAnswer: 0,
    explanation: 'Key prop помогает React идентифицировать элементы в списке для эффективного обновления. Подробнее: https://react.dev/learn/rendering-lists#rules-of-keys',
    category: 'Компоненты',
    difficulty: 'Средний',
    tags: ['компоненты', 'keys'],
    type: 'single',
  },
  {
    question: 'Можно ли использовать index массива как key?',
    options: [
      'Да, всегда',
      'Нет, никогда',
      'Только если список статичный и не изменяется',
      'Только в функциональных компонентах',
    ],
    correctAnswer: 2,
    explanation: 'Index можно использовать только если список статичен. Для динамических списков нужны уникальные ключи. Подробнее: https://react.dev/learn/rendering-lists#rules-of-keys',
    category: 'Компоненты',
    difficulty: 'Средний',
    tags: ['компоненты', 'keys'],
    type: 'single',
  },
  {
    question: 'В чем преимущества composition?',
    options: [
      'Более модульный и переиспользуемый код',
      'Проще тестировать',
      'Лучше читаемость',
      'Все вышеперечисленное',
    ],
    correctAnswer: 3,
    explanation: 'Composition обеспечивает модульность, переиспользуемость, простоту тестирования и улучшает читаемость кода. Подробнее: https://react.dev/learn',
    category: 'Компоненты',
    difficulty: 'Средний',
    tags: ['компоненты', 'composition'],
    type: 'single',
  },
  {
    question: 'Что такое shadow DOM в React?',
    options: [
      'Virtual DOM который использует React',
      'Shadow DOM это браузерная технология, React не использует её напрямую',
      'Скрытый DOM элемент',
      'Специальный React компонент',
    ],
    correctAnswer: 1,
    explanation: 'Shadow DOM это браузерная технология для инкапсуляции. React использует Virtual DOM, не Shadow DOM. Подробнее: https://react.dev/learn/render-and-commit',
    category: 'Компоненты',
    difficulty: 'Средний',
    tags: ['компоненты', 'virtual-dom'],
    type: 'single',
  },
  {
    question: 'Зачем нужны PropTypes?',
    options: [
      'Для документации компонента',
      'Для проверки типов во время разработки',
      'Для выявления потенциальных ошибок',
      'Все вышеперечисленное',
    ],
    correctAnswer: 3,
    explanation: 'PropTypes служат для документации, проверки типов и обнаружения потенциальных ошибок во время разработки. Подробнее: https://react.dev/learn',
    category: 'Компоненты',
    difficulty: 'Средний',
    tags: ['компоненты', 'prop-types'],
    type: 'single',
  },
  {
    question: 'Что такое isRequired в PropTypes?',
    options: [
      'Указывает что prop обязателен',
      'Указывает что prop опционален',
      'Указывает default значение',
      'Указывает тип prop',
    ],
    correctAnswer: 0,
    explanation: 'isRequired указывает что prop является обязательным и React выдаст предупреждение если prop не передан. Подробнее: https://react.dev/learn',
    category: 'Компоненты',
    difficulty: 'Средний',
    tags: ['компоненты', 'prop-types'],
    type: 'single',
  },
  {
    question: 'Как определить default props в функциональном компоненте?',
    options: [
      'Через параметры по умолчанию или Component.defaultProps',
      'Только через defaultProps',
      'Только через параметры',
      'Нельзя определить',
    ],
    correctAnswer: 0,
    explanation: 'В функциональном компоненте можно использовать параметры по умолчанию: function Component({ prop = "default" }) или defaultProps.',
    category: 'Компоненты',
    difficulty: 'Средний',
    tags: ['компоненты', 'defaultprops', 'functional-components'],
    type: 'single',
  },
  {
    question: 'Что такое React.cloneElement?',
    options: [
      'Функция для клонирования и модификации React элемента',
      'React Hook',
      'DOM метод',
      'CSS свойство',
    ],
    correctAnswer: 0,
    explanation: 'cloneElement клонирует React элемент и позволяет передать ему новые props. Подробнее: https://react.dev/learn',
    category: 'Компоненты',
    difficulty: 'Сложный',
    tags: ['компоненты', 'cloneElement'],
    type: 'single',
  },
  {
    question: 'Что такое React.isValidElement?',
    options: [
      'Функция проверяющая является ли элемент валидным React элементом',
      'React Hook',
      'DOM метод',
      'CSS свойство',
    ],
    correctAnswer: 0,
    explanation: 'isValidElement проверяет является ли переданный объект валидным React элементом. Подробнее: https://react.dev/learn',
    category: 'Компоненты',
    difficulty: 'Сложный',
    tags: ['компоненты', 'isValidElement'],
    type: 'single',
  },
  {
    question: 'Что такое React.Children?',
    options: [
      'Утилита для работы с children',
      'React Hook',
      'DOM API',
      'CSS свойство',
    ],
    correctAnswer: 0,
    explanation: 'React.Children предоставляет утилиты для работы с children: map, forEach, count, toArray, only. Подробнее: https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children',
    category: 'Компоненты',
    difficulty: 'Сложный',
    tags: ['компоненты', 'React.Children', 'children'],
    type: 'single',
  },
  {
    question: 'Что такое naming conventions для React компонентов?',
    options: [
      'Имена компонентов должны начинаться с заглавной буквы',
      'Имена могут быть любыми',
      'Имена должны быть в нижнем регистре',
      'Имена не важны',
    ],
    correctAnswer: 0,
    explanation: 'Имена React компонентов должны начинаться с заглавной буквы, чтобы отличаться от обычных HTML элементов. Подробнее: https://react.dev/learn',
    category: 'Компоненты',
    difficulty: 'Легкий',
    tags: ['компоненты', 'naming'],
    type: 'single',
  },
  {
    question: 'Что такое custom hooks в контексте компонентов?',
    options: [
      'Переиспользуемая логика извлекаемая из компонентов',
      'Встроенные React hooks',
      'DOM hooks',
      'CSS hooks',
    ],
    correctAnswer: 0,
    explanation: 'Custom hooks позволяют извлечь логику компонента в переиспользуемую функцию с доступом к hooks. Подробнее: https://react.dev/reference/react',
    category: 'Компоненты',
    difficulty: 'Средний',
    tags: ['компоненты', 'custom-hooks', 'hooks'],
    type: 'single',
  },
];

