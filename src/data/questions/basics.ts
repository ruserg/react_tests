import { Question } from '../../types/question';

export const basicsQuestions: Omit<Question, 'id'>[] = [
  {
    question: 'Что такое React?',
    options: [
      'JavaScript библиотека для создания пользовательских интерфейсов',
      'Фреймворк для бэкенд разработки',
      'База данных',
      'Язык программирования',
    ],
    correctAnswer: 0,
    explanation: 'React - это JavaScript библиотека для создания пользовательских интерфейсов, разработанная Facebook. Подробнее: https://react.dev/learn',
    category: 'Основы',
    difficulty: 'Легкий',
    tags: ['основы', 'react'],
    type: 'single',
  },
  {
    question: 'Что такое JSX?',
    options: [
      'JavaScript XML - синтаксическое расширение для JavaScript',
      'Отдельный язык программирования',
      'База данных',
      'Фреймворк',
    ],
    correctAnswer: 0,
    explanation: 'JSX - это синтаксическое расширение JavaScript, которое позволяет писать HTML-подобный код в JavaScript файлах. Подробнее: https://react.dev/learn/writing-markup-with-jsx',
    category: 'Основы',
    difficulty: 'Легкий',
    tags: ['основы', 'jsx'],
    type: 'single',
  },
  {
    question: 'Что делает метод ReactDOM.render()?',
    options: [
      'Удаляет компонент из DOM',
      'Рендерит React элемент в DOM дерево',
      'Обновляет состояние компонента',
      'Создает новый компонент',
    ],
    correctAnswer: 1,
    explanation: 'ReactDOM.render() принимает React элемент и рендерит его в указанный DOM элемент. Подробнее: https://react.dev/learn',
    category: 'Основы',
    difficulty: 'Средний',
    tags: ['основы', 'rendering'],
    type: 'single',
  },
  {
    question: 'Что такое Virtual DOM?',
    options: [
      'Реальная часть браузера',
      'Виртуальное представление DOM в памяти React',
      'База данных',
      'API для работы с файлами',
    ],
    correctAnswer: 1,
    explanation: 'Virtual DOM - это JavaScript представление реального DOM, которое позволяет React эффективно обновлять UI. Подробнее: https://react.dev/learn/render-and-commit',
    category: 'Основы',
    difficulty: 'Средний',
    tags: ['virtual-dom', 'performance'],
    type: 'single',
  },
  {
    question: 'Какая команда используется для создания нового React приложения?',
    options: [
      'npx create-react-app my-app',
      'npm create react-app my-app',
      'react new my-app',
      'create my-react-app',
    ],
    correctAnswer: 0,
    explanation: 'npx create-react-app - стандартная команда для создания нового React приложения. Подробнее: https://react.dev/learn/start-a-new-react-project',
    category: 'Основы',
    difficulty: 'Легкий',
    tags: ['основы', 'create-react-app'],
    type: 'single',
  },
  {
    question: 'Что такое reconciliation в React?',
    options: [
      'Процесс синхронизации Virtual DOM с реальным DOM',
      'Работа с API',
      'Управление состоянием',
      'Обработка событий',
    ],
    correctAnswer: 0,
    explanation: 'Reconciliation - процесс обновления DOM для соответствия новому Virtual DOM дереву. Подробнее: https://react.dev/learn/render-and-commit',
    category: 'Основы',
    difficulty: 'Сложный',
    tags: ['основы', 'reconciliation', 'virtual-dom'],
    type: 'single',
  },
  {
    question: 'Какой метод используется для условного рендеринга в React?',
    options: [
      'Только if-else',
      'Только тернарный оператор',
      'if-else, тернарный оператор, && оператор',
      'Только && оператор',
    ],
    correctAnswer: 2,
    explanation: 'В React можно использовать if-else, тернарный оператор и логический && для условного рендеринга. Подробнее: https://react.dev/learn/conditional-rendering',
    category: 'Основы',
    difficulty: 'Легкий',
    tags: ['основы', 'conditional-rendering'],
    type: 'single',
  },
  {
    question: 'Что такое React Fragment?',
    options: [
      'Полноценный DOM элемент',
      'Пустой компонент-обертка без добавления DOM элементов',
      'Событие React',
      'Метод работы с API',
    ],
    correctAnswer: 1,
    explanation: 'Fragment позволяет группировать элементы без добавления лишних DOM узлов. Подробнее: https://react.dev/reference/react/Fragment',
    category: 'Основы',
    difficulty: 'Легкий',
    tags: ['основы', 'fragment'],
    type: 'single',
  },
  {
    question: 'Что такое JSX transform?',
    options: [
      'Преобразование JSX в вызовы React.createElement',
      'Удаление JSX из проекта',
      'Добавление JSX в браузер',
      'Компиляция TypeScript',
    ],
    correctAnswer: 0,
    explanation: 'JSX transform - это процесс компиляции JSX синтаксиса в вызовы React.createElement или в новый JSX transform React 17+. Подробнее: https://react.dev/learn/writing-markup-with-jsx',
    category: 'Основы',
    difficulty: 'Средний',
    tags: ['основы', 'jsx'],
    type: 'single',
  },
  {
    question: 'Какая основная цель React?',
    options: [
      'Работа с базами данных',
      'Создание масштабируемых и поддерживаемых пользовательских интерфейсов',
      'Компиляция кода',
      'Работа с сервером',
    ],
    correctAnswer: 1,
    explanation: 'React предназначен для создания масштабируемых и поддерживаемых пользовательских интерфейсов через компонентный подход. Подробнее: https://react.dev/learn',
    category: 'Основы',
    difficulty: 'Легкий',
    tags: ['основы', 'react'],
    type: 'single',
  },
  {
    question: 'Можно ли использовать React без JSX?',
    options: [
      'Нет, JSX обязателен',
      'Да, используя React.createElement',
      'Только с TypeScript',
      'Только в старых версиях',
    ],
    correctAnswer: 1,
    explanation: 'JSX можно использовать, но это необязательно. Можно писать React компоненты используя React.createElement. Подробнее: https://react.dev/learn/writing-markup-with-jsx',
    category: 'Основы',
    difficulty: 'Средний',
    tags: ['основы', 'jsx', 'createElement'],
    type: 'single',
  },
  {
    question: 'Что такое компонентный подход в React?',
    options: [
      'Использование одного большого файла',
      'Разбиение UI на независимые переиспользуемые компоненты',
      'Работа только с классами',
      'Использование модулей',
    ],
    correctAnswer: 1,
    explanation: 'Компонентный подход означает разбиение UI на независимые, переиспользуемые части - компоненты. Подробнее: https://react.dev/learn',
    category: 'Основы',
    difficulty: 'Легкий',
    tags: ['основы', 'компоненты'],
    type: 'single',
  },
  {
    question: 'Что такое односторонний поток данных в React?',
    options: [
      'Данные передаются только вверх',
      'Данные передаются от родителя к ребенку через props',
      'Данные передаются только вниз',
      'Данные не передаются',
    ],
    correctAnswer: 1,
    explanation: 'Односторонний поток данных означает, что props передаются от родительского компонента к дочернему, а не наоборот. Подробнее: https://react.dev/learn/passing-props-to-a-component',
    category: 'Основы',
    difficulty: 'Средний',
    tags: ['основы', 'props', 'data-flow'],
    type: 'single',
  },
  {
    question: 'Что такое React элемент?',
    options: [
      'Реальный DOM элемент',
      'Легковесное описание того, что вы хотите увидеть на экране',
      'Функция компонента',
      'Класс компонента',
    ],
    correctAnswer: 1,
    explanation: 'React элемент - это легковесное описание UI, обычный JavaScript объект. Подробнее: https://react.dev/learn',
    category: 'Основы',
    difficulty: 'Легкий',
    tags: ['основы', 'react-element'],
    type: 'single',
  },
  {
    question: 'Какие части включает React экосистема?',
    options: [
      'Только React библиотека',
      'React, ReactDOM, React Router, Redux и множество других инструментов',
      'Только React и Redux',
      'React и Node.js',
    ],
    correctAnswer: 1,
    explanation: 'React экосистема включает множество инструментов: React, ReactDOM, маршрутизация, state management библиотеки и другие. Подробнее: https://react.dev/learn',
    category: 'Основы',
    difficulty: 'Легкий',
    tags: ['основы', 'react-ecosystem'],
    type: 'single',
  },
  {
    question: 'Что такое diffing в React?',
    options: [
      'Процесс сравнения двух Virtual DOM деревьев',
      'Работа с базами данных',
      'Удаление компонентов',
      'Создание компонентов',
    ],
    correctAnswer: 0,
    explanation: 'Diffing - это процесс сравнения нового Virtual DOM дерева со старым для определения минимальных изменений. Подробнее: https://react.dev/learn/render-and-commit',
    category: 'Основы',
    difficulty: 'Средний',
    tags: ['основы', 'diffing', 'virtual-dom'],
    type: 'single',
  },
  {
    question: 'Что такое React дерево компонентов?',
    options: [
      'Физическая структура в браузере',
      'Иерархическая структура React компонентов',
      'DOM дерево',
      'База данных',
    ],
    correctAnswer: 1,
    explanation: 'React дерево компонентов - это иерархическая структура, показывающая родительско-дочерние отношения между компонентами. Подробнее: https://react.dev/learn',
    category: 'Основы',
    difficulty: 'Легкий',
    tags: ['основы', 'component-tree'],
    type: 'single',
  },
  {
    question: 'Что означает "декларативный" подход React?',
    options: [
      'Описание того, как что-то сделать',
      'Описание того, КАК должно выглядеть UI, а не как его реализовать',
      'Использование императивных команд',
      'Работа с базами данных',
    ],
    correctAnswer: 1,
    explanation: 'Декларативный подход означает описание желаемого результата, а не пошаговых инструкций его достижения. Подробнее: https://react.dev/learn',
    category: 'Основы',
    difficulty: 'Средний',
    tags: ['основы', 'declarative'],
    type: 'single',
  },
  {
    question: 'Что такое Babel в контексте React?',
    options: [
      'React компонент',
      'JavaScript транспайлер, который компилирует JSX и современный JavaScript',
      'База данных',
      'Package manager',
    ],
    correctAnswer: 1,
    explanation: 'Babel - это транспайлер, который преобразует современный JavaScript и JSX в код, понятный старым браузерам. Подробнее: https://react.dev/learn',
    category: 'Основы',
    difficulty: 'Средний',
    tags: ['основы', 'babel', 'build-tools'],
    type: 'single',
  },
  {
    question: 'Какая разница между React и ReactDOM?',
    options: [
      'Нет разницы',
      'React - ядро библиотеки, ReactDOM - рендеринг в DOM',
      'ReactDOM - старая версия React',
      'ReactDOM - база данных',
    ],
    correctAnswer: 1,
    explanation: 'React - это ядро библиотеки для создания компонентов, ReactDOM - это библиотека для рендеринга в DOM окружение. Подробнее: https://react.dev/learn',
    category: 'Основы',
    difficulty: 'Легкий',
    tags: ['основы', 'react', 'react-dom'],
    type: 'single',
  },
  {
    question: 'Что такое портал (Portal) в React?',
    options: [
      'Способ рендерить дочерние элементы в узел DOM вне иерархии компонента',
      'Новый тип компонента',
      'База данных',
      'API для работы с файлами',
    ],
    correctAnswer: 0,
    explanation: 'Portal позволяет рендерить дочерние элементы в узел DOM, который находится вне DOM-иерархии родительского компонента. Подробнее: https://react.dev/reference/react-dom/createPortal',
    category: 'Основы',
    difficulty: 'Сложный',
    tags: ['основы', 'portal'],
    type: 'single',
  },
  {
    question: 'Что такое React DevTools?',
    options: [
      'Редактор кода',
      'Расширение для браузера для отладки React приложений',
      'Фреймворк',
      'База данных',
    ],
    correctAnswer: 1,
    explanation: 'React DevTools - это расширение для Chrome и Firefox, позволяющее инспектировать React компоненты, props и state. Подробнее: https://react.dev/learn',
    category: 'Основы',
    difficulty: 'Легкий',
    tags: ['основы', 'devtools'],
    type: 'single',
  },
  {
    question: 'Что такое Prop Drilling?',
    options: [
      'Передача props через несколько уровней компонентов',
      'Создание props',
      'Удаление props',
      'Клонирование props',
    ],
    correctAnswer: 0,
    explanation: 'Prop drilling происходит когда props передаются через множество промежуточных компонентов только для того, чтобы достичь глубоко вложенного компонента. Подробнее: https://react.dev/learn/passing-props-to-a-component',
    category: 'Основы',
    difficulty: 'Средний',
    tags: ['основы', 'props'],
    type: 'single',
  },
  {
    question: 'Что такое React ключ (key) и почему он важен?',
    options: [
      'Уникальная строка для идентификации элементов в списках',
      'Внутренний state компонента',
      'CSS класс',
      'JavaScript переменная',
    ],
    correctAnswer: 0,
    explanation: 'Key - это специальный строковый атрибут, который помогает React идентифицировать элементы списка, улучшая производительность при обновлениях. Подробнее: https://react.dev/learn/rendering-lists#rules-of-keys',
    category: 'Основы',
    difficulty: 'Средний',
    tags: ['основы', 'keys'],
    type: 'single',
  },
  {
    question: 'Можно ли использовать React в мобильной разработке?',
    options: [
      'Нет, только для веб',
      'Да, через React Native',
      'Только с дополнительными библиотеками',
      'Только на Android',
    ],
    correctAnswer: 1,
    explanation: 'React можно использовать для мобильной разработки через React Native, который использует те же концепции React. Подробнее: https://react.dev/learn',
    category: 'Основы',
    difficulty: 'Легкий',
    tags: ['основы', 'react-native'],
    type: 'single',
  },
  {
    question: 'Что такое контролируемый компонент?',
    options: [
      'Компонент без состояния',
      'Компонент, в котором React контролирует значение формы через state',
      'Компонент только для чтения',
      'Внешний компонент',
    ],
    correctAnswer: 1,
    explanation: 'Контролируемый компонент - это компонент формы, значение которого контролируется React через state. Подробнее: https://react.dev/learn',
    category: 'Основы',
    difficulty: 'Средний',
    tags: ['основы', 'controlled-component', 'forms'],
    type: 'single',
  },
  {
    question: 'Что такое неконтролируемый компонент?',
    options: [
      'Компонент, который не рендерится',
      'Компонент формы, данные которого обрабатываются нативным DOM',
      'Компонент без props',
      'Устаревший компонент',
    ],
    correctAnswer: 1,
    explanation: 'Неконтролируемый компонент - это компонент формы, данные которого хранятся в нативном DOM, а не в React state. Подробнее: https://react.dev/learn',
    category: 'Основы',
    difficulty: 'Средний',
    tags: ['основы', 'uncontrolled-component', 'forms'],
    type: 'single',
  },
  {
    question: 'Что такое synthetic event в React?',
    options: [
      'Событие из базы данных',
      'Кроссбраузерная обертка над нативными событиями браузера',
      'Старое событие',
      'Тип компонента',
    ],
    correctAnswer: 1,
    explanation: 'Synthetic Event - это кроссбраузерная обертка React над нативными событиями, которая обеспечивает согласованное поведение во всех браузерах. Подробнее: https://react.dev/learn',
    category: 'Основы',
    difficulty: 'Средний',
    tags: ['основы', 'events', 'synthetic-events'],
    type: 'single',
  },
  {
    question: 'Какие из следующих утверждений о React верны?',
    options: [
      'React это фреймворк',
      'React использует Virtual DOM',
      'React обязательно требует TypeScript',
      'React не поддерживает функциональные компоненты',
    ],
    correctAnswer: 1,
    explanation: 'React использует Virtual DOM для эффективного обновления UI. Это библиотека, не фреймворк. Подробнее: https://react.dev/learn/render-and-commit',
    category: 'Основы',
    difficulty: 'Средний',
    tags: ['основы', 'react', 'virtual-dom'],
    type: 'single',
  },
  {
    question: 'Что такое компонент высшего порядка (HOC)?',
    options: [
      'Компонент, который принимает компонент и возвращает новый компонент',
      'Компонент с большим количеством props',
      'Базовый компонент React',
      'DOM элемент',
    ],
    correctAnswer: 0,
    explanation: 'HOC (Higher-Order Component) - это функция, которая принимает компонент и возвращает новый компонент с дополнительной функциональностью. Подробнее: https://react.dev/learn',
    category: 'Основы',
    difficulty: 'Сложный',
    tags: ['основы', 'hoc', 'patterns'],
    type: 'single',
  },
  {
    question: 'Что такое Render Prop паттерн?',
    options: [
      'Props для рендеринга',
      'Паттерн компонента с prop значением которого является функция',
      'Тип компонента',
      'DOM API',
    ],
    correctAnswer: 1,
    explanation: 'Render Prop - это паттерн, где компонент получает функцию как prop и использует её для рендеринга части UI. Подробнее: https://react.dev/learn',
    category: 'Основы',
    difficulty: 'Сложный',
    tags: ['основы', 'render-props', 'patterns'],
    type: 'single',
  },
  {
    question: 'Что означает "композиция" в React?',
    options: [
      'Создание компонентов из более простых компонентов',
      'Удаление компонентов',
      'Копирование компонентов',
      'Импорт компонентов',
    ],
    correctAnswer: 0,
    explanation: 'Композиция в React означает создание сложных компонентов путем комбинирования простых, переиспользуемых компонентов. Подробнее: https://react.dev/learn',
    category: 'Основы',
    difficulty: 'Средний',
    tags: ['основы', 'composition', 'patterns'],
    type: 'single',
  },
  {
    question: 'Что такое React.Component?',
    options: [
      'Базовый класс для всех классовых компонентов React',
      'Функциональный компонент',
      'Hook',
      'DOM элемент',
    ],
    correctAnswer: 0,
    explanation: 'React.Component - это базовый класс ES6, который расширяется для создания компонентов с состоянием и методами жизненного цикла. Подробнее: https://react.dev/learn',
    category: 'Основы',
    difficulty: 'Средний',
    tags: ['основы', 'class-components'],
    type: 'single',
  },
  {
    question: 'Что такое функциональный компонент?',
    options: [
      'Компонент без функциональности',
      'JavaScript функция, которая возвращает JSX',
      'Только классовый компонент',
      'DOM элемент',
    ],
    correctAnswer: 1,
    explanation: 'Функциональный компонент - это обычная JavaScript функция, которая принимает props и возвращает React элементы. Подробнее: https://react.dev/learn',
    category: 'Основы',
    difficulty: 'Легкий',
    tags: ['основы', 'functional-components'],
    type: 'single',
  },
  {
    question: 'Какие преимущества функциональных компонентов над классовыми?',
    options: [
      'Более короткий и простой синтаксис',
      'Лучшая производительность',
      'Проще тестировать',
      'Все вышеперечисленное',
    ],
    correctAnswer: 3,
    explanation: 'Функциональные компоненты проще, короче, часто лучше оптимизируются и легче тестируются. Подробнее: https://react.dev/learn',
    category: 'Основы',
    difficulty: 'Средний',
    tags: ['основы', 'functional-components', 'class-components'],
    type: 'single',
  },
  {
    question: 'Что такое React.StrictMode?',
    options: [
      'Режим разработчика для поиска потенциальных проблем',
      'Производственный режим',
      'Тестовый режим',
      'Режим отладки',
    ],
    correctAnswer: 0,
    explanation: 'StrictMode - это инструмент для выявления потенциальных проблем в приложении. Работает только в режиме разработки. Подробнее: https://react.dev/reference/react/StrictMode',
    category: 'Основы',
    difficulty: 'Средний',
    tags: ['основы', 'strict-mode'],
    type: 'single',
  },
  {
    question: 'Что такое prop-types?',
    options: [
      'Метод валидации типов props во время разработки',
      'Типы из TypeScript',
      'CSS свойство',
      'React Hook',
    ],
    correctAnswer: 0,
    explanation: 'PropTypes - это механизм проверки типов props во время выполнения в режиме разработки для обнаружения ошибок. Подробнее: https://react.dev/learn',
    category: 'Основы',
    difficulty: 'Средний',
    tags: ['основы', 'prop-types', 'validation'],
    type: 'single',
  },
  {
    question: 'Что такое defaultProps?',
    options: [
      'Значения по умолчанию для props',
      'Обязательные props',
      'Внутренние props',
      'Приватные props',
    ],
    correctAnswer: 0,
    explanation: 'defaultProps позволяет определить значения по умолчанию для props компонента. Подробнее: https://react.dev/learn/passing-props-to-a-component',
    category: 'Основы',
    difficulty: 'Легкий',
    tags: ['основы', 'defaultprops', 'props'],
    type: 'single',
  },
  {
    question: 'Что такое React Fiber?',
    options: [
      'Новый алгоритм reconciliation в React',
      'Физический компонент',
      'База данных',
      'Сеть',
    ],
    correctAnswer: 0,
    explanation: 'React Fiber - это новая архитектура reconciliation, которая обеспечивает инкрементальный рендеринг и приоритизацию обновлений. Подробнее: https://react.dev/learn',
    category: 'Основы',
    difficulty: 'Сложный',
    tags: ['основы', 'react-fiber', 'architecture'],
    type: 'single',
  },
  {
    question: 'Что такое useEffect cleanup функция?',
    options: [
      'Удаление эффектов',
      'Функция, которая выполняется при размонтировании компонента',
      'Очистка props',
      'Удаление state',
    ],
    correctAnswer: 1,
    explanation: 'Cleanup функция в useEffect выполняется при размонтировании компонента или перед следующим запуском эффекта. Подробнее: https://react.dev/reference/react/useEffect',
    category: 'Основы',
    difficulty: 'Средний',
    tags: ['основы', 'useEffect', 'lifecycle'],
    type: 'single',
  },
  {
    question: 'Что такое React.Lazy?',
    options: [
      'Компонент для ленивой загрузки других компонентов',
      'Устаревший компонент',
      'Медленный компонент',
      'React Hook',
    ],
    correctAnswer: 0,
    explanation: 'React.lazy позволяет динамически импортировать компоненты для code splitting и улучшения производительности. Подробнее: https://react.dev/learn/code-splitting',
    category: 'Основы',
    difficulty: 'Средний',
    tags: ['основы', 'lazy', 'code-splitting'],
    type: 'single',
  },
  {
    question: 'Что такое React.memo?',
    options: [
      'Мемоизация компонента для предотвращения лишних рендеров',
      'Запоминание state',
      'React Hook',
      'База данных',
    ],
    correctAnswer: 0,
    explanation: 'React.memo - это HOC, который мемоизирует результат компонента, предотвращая лишние рендеры при одинаковых props. Подробнее: https://react.dev/reference/react/memo',
    category: 'Основы',
    difficulty: 'Средний',
    tags: ['основы', 'memo', 'performance'],
    type: 'single',
  },
  {
    question: 'Что такое встроенные стили в React?',
    options: [
      'Стили передаются как объекты через prop style',
      'Внутренние CSS',
      'Встроенные HTML стили',
      'JavaScript стили',
    ],
    correctAnswer: 0,
    explanation: 'В React стили можно передавать через prop style как JavaScript объект с camelCase свойствами. Подробнее: https://react.dev/learn',
    category: 'Основы',
    difficulty: 'Легкий',
    tags: ['основы', 'styling'],
    type: 'single',
  },
  {
    question: 'Что происходит если не указать key для элементов списка?',
    options: [
      'React выдаст предупреждение',
      'Все элементы получат одинаковый key',
      'React автоматически создаст keys',
      'Компонент не отрендерится',
    ],
    correctAnswer: 0,
    explanation: 'React выдаст предупреждение в консоли и будет использовать индекс массива как key, что может вызвать проблемы производительности. Подробнее: https://react.dev/learn/rendering-lists#rules-of-keys',
    category: 'Основы',
    difficulty: 'Легкий',
    tags: ['основы', 'keys'],
    type: 'single',
  },
  {
    question: 'Что такое ref в React?',
    options: [
      'Ссылка на DOM элемент или экземпляр компонента',
      'Пропс',
      'State',
      'JavaScript переменная',
    ],
    correctAnswer: 0,
    explanation: 'Ref предоставляет способ доступа к DOM элементам или экземплярам компонентов напрямую в React. Подробнее: https://react.dev/learn',
    category: 'Основы',
    difficulty: 'Средний',
    tags: ['основы', 'refs'],
    type: 'single',
  },
  {
    question: 'Что такое forwardRef?',
    options: [
      'Механизм передачи ref родительскому компоненту',
      'Удаление ref',
      'Создание ref',
      'Копирование ref',
    ],
    correctAnswer: 0,
    explanation: 'forwardRef позволяет компоненту получить ref и передать его дальше дочернему элементу. Подробнее: https://react.dev/reference/react/forwardRef',
    category: 'Основы',
    difficulty: 'Сложный',
    tags: ['основы', 'refs', 'forwardref'],
    type: 'single',
  },
  {
    question: 'Что такое code splitting?',
    options: [
      'Разделение кода на части для загрузки по требованию',
      'Удаление кода',
      'Объединение кода',
      'Компиляция кода',
    ],
    correctAnswer: 0,
    explanation: 'Code splitting - это техника разделения бандла на более мелкие части, которые загружаются по мере необходимости. Подробнее: https://react.dev/learn/render-and-commit',
    category: 'Основы',
    difficulty: 'Средний',
    tags: ['основы', 'code-splitting', 'performance'],
    type: 'single',
  },
  {
    question: 'Что такое ленивая загрузка (lazy loading)?',
    options: [
      'Загрузка компонентов только когда они нужны',
      'Медленная загрузка',
      'Всегда полная загрузка',
      'Загрузка по таймеру',
    ],
    correctAnswer: 0,
    explanation: 'Lazy loading - это техника загрузки компонентов только при их фактическом использовании для улучшения производительности. Подробнее: https://react.dev/learn/render-and-commit',
    category: 'Основы',
    difficulty: 'Средний',
    tags: ['основы', 'lazy-loading', 'performance'],
    type: 'single',
  },
  {
    question: 'Что такое React Error Boundaries?',
    options: [
      'Компоненты для перехвата ошибок в дочерних компонентах',
      'Блоки кода',
      'Try-catch блоки',
      'Компоненты для тестирования',
    ],
    correctAnswer: 0,
    explanation: 'Error Boundaries - это компоненты React, которые перехватывают ошибки JavaScript в любом месте дерева дочерних компонентов. Подробнее: https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary',
    category: 'Основы',
    difficulty: 'Сложный',
    tags: ['основы', 'error-boundaries'],
    type: 'single',
  },
  {
    question: 'Что такое React.Fragment короткий синтаксис?',
    options: [
      '<></> - пустые угловые скобки',
      '<Fragment></Fragment>',
      '<ReactFragment></ReactFragment>',
      'Специальная функция',
    ],
    correctAnswer: 0,
    explanation: 'Короткий синтаксис React.Fragment - это <></>, который позволяет группировать элементы без создания дополнительного DOM узла. Подробнее: https://react.dev/reference/react/Fragment',
    category: 'Основы',
    difficulty: 'Легкий',
    tags: ['основы', 'fragment'],
    type: 'single',
  },
  {
    question: 'Какой вариант правильно обрабатывает клик в React?',
    options: [
      'const handleClick = () => {\n  console.log("Clicked");\n}',
      'const handleClick = () => {\n  console.log(\'Clicked\');\n}',
    ],
    correctAnswer: 0,
    explanation: 'В React event handlers можно использовать одинарные или двойные кавычки, оба варианта корректны. Подробнее: https://react.dev/learn/responding-to-events',
    category: 'Основы',
    difficulty: 'Средний',
    tags: ['основы', 'events', 'syntax'],
    type: 'code',
  },
  {
    question: 'Какая реализация компонента корректна?',
    options: [
      'function MyComponent() {\n  return <div>Hello</div>;\n}',
      'function MyComponent {\n  return <div>Hello</div>;\n}',
    ],
    correctAnswer: 0,
    explanation: 'Функциональный компонент в React должен быть объявлен как function с круглыми скобками после имени. Подробнее: https://react.dev/learn/describing-the-ui',
    category: 'Основы',
    difficulty: 'Легкий',
    tags: ['основы', 'components', 'syntax'],
    type: 'code',
  },
  {
    question: 'Какой вариант правильно использует useState?',
    options: [
      'const [count, setCount] = useState(0);',
      'const [count, setCount] = useState[0];',
    ],
    correctAnswer: 0,
    explanation: 'useState принимает начальное значение в круглых скобках, а не квадратных. Подробнее: https://react.dev/reference/react/useState',
    category: 'Основы',
    difficulty: 'Средний',
    tags: ['основы', 'hooks', 'useState', 'syntax'],
    type: 'code',
  },
  {
    question: 'Какая реализация useEffect корректна?',
    options: [
      'useEffect(() => {\n  console.log("Mounted");\n  return () => {\n    console.log("Unmounted");\n  };\n}, []);',
      'useEffect(() => {\n  console.log("Mounted");\n}, [dependency]);',
    ],
    correctAnswer: 0,
    explanation: 'useEffect с пустым массивом зависимостей выполняется один раз при монтировании и возвращает cleanup функцию. Второй вариант тоже корректный, но первый демонстрирует cleanup. Подробнее: https://react.dev/reference/react/useEffect',
    category: 'Основы',
    difficulty: 'Сложный',
    tags: ['основы', 'hooks', 'useEffect', 'cleanup'],
    type: 'code',
    isLongCode: true,
  },
  {
    question: 'Какой вариант правильно передает props?',
    options: [
      'function Component({ name, age }) {\n  return <div>{name}</div>;\n}',
      'function Component(props) {\n  return <div>{props.name}</div>;\n}',
    ],
    correctAnswer: 0,
    explanation: 'Оба варианта корректны! Первый использует деструктуризацию props, второй - обращение через точку. Деструктуризация более современный подход. Подробнее: https://react.dev/learn/passing-props-to-a-component',
    category: 'Основы',
    difficulty: 'Легкий',
    tags: ['основы', 'props', 'destructuring'],
    type: 'code',
  },
  {
    question: 'Какой вариант правильно обрабатывает форму?',
    options: [
      'const handleSubmit = (e) => {\n  e.preventDefault();\n  console.log("Submitted");\n};\nreturn <form onSubmit={handleSubmit}>',
      'const handleSubmit = (e) => {\n  console.log("Submitted");\n};\nreturn <form onSubmit={handleSubmit}>',
    ],
    correctAnswer: 0,
    explanation: 'При работе с формами в React нужно вызывать e.preventDefault() чтобы предотвратить стандартное поведение браузера. Подробнее: https://react.dev/learn/forms',
    category: 'Основы',
    difficulty: 'Средний',
    tags: ['основы', 'forms', 'events'],
    type: 'code',
    isLongCode: true,
  },
  {
    question: 'Какой компонент правильно условно рендерит?',
    options: [
      'function Component({ show }) {\n  return show && <div>Visible</div>;\n}',
      'function Component({ show }) {\n  if (show) return <div>Visible</div>;\n  return null;\n}',
    ],
    correctAnswer: 0,
    explanation: 'Оба варианта корректны! Первый использует логический && для условного рендеринга, второй - if/return. Оба способа работают одинаково. Подробнее: https://react.dev/learn/conditional-rendering',
    category: 'Основы',
    difficulty: 'Легкий',
    tags: ['основы', 'conditional-rendering'],
    type: 'code',
  },
  {
    question: 'Какой вариант правильно использует map для списков?',
    options: [
      'function List({ items }) {\n  return items.map(item => <div key={item.id}>{item.name}</div>);\n}',
      'function List({ items }) {\n  return items.map((item, index) => <div key={index}>{item.name}</div>);\n}',
    ],
    correctAnswer: 0,
    explanation: 'Первый вариант использует уникальный id, что является рекомендуемым подходом. Второй вариант с index тоже работает, но не рекомендуется если элементы могут менять порядок. Подробнее: https://react.dev/learn/rendering-lists#rules-of-keys',
    category: 'Основы',
    difficulty: 'Средний',
    tags: ['основы', 'lists', 'keys'],
    type: 'code',
  },
  {
    question: 'Какой вариант правильно использует контекст?',
    options: [
      'const ThemeContext = createContext();\nfunction App() {\n  return (\n    <ThemeContext.Provider value="dark">\n      <Child />\n    </ThemeContext.Provider>\n  );\n}',
      'const ThemeContext = createContext();\nfunction App() {\n  const theme = useContext(ThemeContext);\n  return <Child />;\n}',
    ],
    correctAnswer: 0,
    explanation: 'Первый вариант правильно создает и провайдит контекст через Provider. Второй вариант пытается использовать useContext без Provider. Подробнее: https://react.dev/reference/react/useContext',
    category: 'Основы',
    difficulty: 'Сложный',
    tags: ['основы', 'context', 'useContext'],
    type: 'code',
    isLongCode: true,
  },
  {
    question: 'Какой вариант правильно обрабатывает событие onChange?',
    options: [
      'const handleChange = (e) => {\n  setValue(e.target.value);\n};\nreturn <input value={value} onChange={handleChange} />;',
      'const handleChange = (e) => {\n  setValue(e.target);\n};\nreturn <input value={value} onChange={handleChange} />;',
    ],
    correctAnswer: 0,
    explanation: 'В событии onChange нужно использовать e.target.value для получения введенного значения. e.target - это сам элемент input. Подробнее: https://react.dev/learn/forms',
    category: 'Основы',
    difficulty: 'Средний',
    tags: ['основы', 'forms', 'events'],
    type: 'code',
    isLongCode: true,
  },
  {
    question: 'Какой вариант мемоизирует вычисление?',
    options: [
      'const expensive = useMemo(() => {\n  return data.filter(item => item.active);\n}, [data]);',
      'const expensive = data.filter(item => item.active);',
    ],
    correctAnswer: 0,
    explanation: 'useMemo мемоизирует результат вычисления и пересчитывает его только при изменении зависимостей. Второй вариант будет пересчитываться при каждом рендере. Подробнее: https://react.dev/reference/react/useMemo',
    category: 'Основы',
    difficulty: 'Сложный',
    tags: ['основы', 'hooks', 'useMemo', 'performance'],
    type: 'code',
  },
];

